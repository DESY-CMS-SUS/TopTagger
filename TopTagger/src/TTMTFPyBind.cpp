#include "TopTagger/TopTagger/include/TTMTFPyBind.h"

#include "TopTagger/TopTagger/include/TopTaggerUtilities.h"
#include "TopTagger/TopTagger/include/TopObject.h"
#include "TopTagger/TopTagger/include/TopTaggerResults.h"
#include "TopTagger/CfgParser/include/Context.hh"
#include "TopTagger/CfgParser/include/CfgDocument.hh"
#include "TopTagger/CfgParser/include/TTException.h"

#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <memory>
#include <vector>
#include <iostream>

#ifdef DOTENSORFLOWPYBIND
static std::string embeddedTensorflowScript = ""
"import os\n"
"import numpy as np\n"
"import tensorflow as tf\n"
"sess = x = y = None\n"
"\n"
"def load_graph(frozen_graph_filename):\n"
"    graph_def = tf.GraphDef()\n"
"    with tf.gfile.GFile(frozen_graph_filename, \"rb\") as f:\n"
"        graph_def.ParseFromString(f.read())\n"
"    with tf.Graph().as_default() as graph:\n"
"        tf.import_graph_def(graph_def, input_map=None, return_elements=None, name=\"\", op_dict=None, producer_op_list=None)\n"
"    return graph\n"
"\n"
"def start_session(frozen_graph_filename):\n"
"    global sess\n"
"    graph = load_graph(frozen_graph_filename)\n"
"    sess = tf.Session(graph=graph)\n"
"\n"
"def eval_session(inputs, outputs):\n"
"    outputs.update(sess.run(dict(zip(outputs.keys(), outputs.keys())), feed_dict=inputs))\n";
#endif

void TTMTFPyBind::getParameters(const cfg::CfgDocument* cfgDoc, const std::string& localContextName)
{
#ifdef DOTENSORFLOWPYBIND
    //Construct contexts
    cfg::Context commonCxt("Common");
    cfg::Context localCxt(localContextName);

    discriminator_ = cfgDoc->get("discCut",      localCxt, -999.9);
    modelFile_     = cfgDoc->get("modelFile",    localCxt, "");
    inputOp_       = cfgDoc->get("inputOp",      localCxt, "x");
    outputOp_      = cfgDoc->get("outputOp",     localCxt, "y");

    csvThreshold_  = cfgDoc->get("csvThreshold", localCxt, -999.9);
    bEtaCut_       = cfgDoc->get("bEtaCut",      localCxt, -999.9);
    maxNbInTop_    = cfgDoc->get("maxNbInTop",   localCxt, -1);

    int iVar = 0;
    bool keepLooping;
    do
    {
        keepLooping = false;

        //Get variable name
        std::string varName = cfgDoc->get("mvaVar", iVar, localCxt, "");

        //if it is a non empty string save in vector
        if(varName.size() > 0)
        {
            keepLooping = true;

            vars_.push_back(varName);
        }
        ++iVar;
    }
    while(keepLooping);

    initializePyInterpreter();

    //create function arguements tuple
    PyObject *pArgs = PyTuple_New(1);
    PyTuple_SetItem(pArgs, 0, PyString_FromString(modelFile_.c_str()));

    //start the tensorflow session
    callPython("start_session", pArgs);

    Py_DECREF(pArgs);

#else
    THROW_TTEXCEPTION("ERROR: TopTagger not compiled with python support!!!");
#endif
}

void TTMTFPyBind::run(TopTaggerResults& ttResults)
{
#ifdef DOTENSORFLOWPYBIND
    //Get the list of top candidates as generated by the clustering algo
    std::vector<TopObject>& topCandidates = ttResults.getTopCandidates();
    //Get the list of final tops into which we will stick candidates
    std::vector<TopObject*>& tops = ttResults.getTops();

    //create numpy array for input data
    npy_intp sizearray[2] = {1, static_cast<npy_intp>(vars_.size())};
    //PyObject* nparray = PyArray_SimpleNewFromData(2, sizearray, NPY_FLOAT, data);
    PyObject* nparray = PyArray_SimpleNew(2, sizearray, NPY_FLOAT);

    // create input feed dict 
    PyObject *inputs = PyDict_New();
    PyDict_SetItemString(inputs, inputOp_.c_str(), nparray);

    // create dict of output nodes 
    PyObject *outputs = PyDict_New();
    PyObject* outputOpName = PyString_FromString(outputOp_.c_str());
    PyDict_SetItem(outputs, outputOpName, Py_None);

    // create arguements tuple 
    PyObject *pArgs = PyTuple_New(2);
    PyTuple_SetItem(pArgs, 0, inputs);
    PyTuple_SetItem(pArgs, 1, outputs);
    
    for(auto& topCand : topCandidates)
    {
        //We only want to apply the MVA algorithm to triplet tops
        if(topCand.getNConstituents() == 3)
        {
            //Prepare data from top candidate (this code is shared with training tuple producer)
            //Perhaps one day the intermediate map can be bypassed ...
            std::map<std::string, double> varMap = ttUtility::createMVAInputs(topCand, csvThreshold_);

            //populate tensor based on desired input variables 
            for(unsigned int i = 0; i < vars_.size(); ++i)
            {
                *static_cast<float*>(PyArray_GETPTR2(nparray, 0, i)) = varMap[vars_[i]];
            }

            callPython("eval_session", pArgs);

            //Get output discriminator
            PyObject *discriminators = PyDict_GetItem(outputs, outputOpName);
            double discriminator = -999.9;
            if(PyArray_Check(discriminators))
            {
                discriminator = static_cast<double>(*static_cast<float*>(PyArray_GETPTR2(discriminators, 0, 0)));
                topCand.setDiscriminator(discriminator);
            }
            else
            {
                THROW_TTEXCEPTION("Returned object is not a numpy array!!!");
            }

            //Check number of b-tagged jets in the top
            bool passBrequirements = maxNbInTop_ < 0 || topCand.getNBConstituents(csvThreshold_, bEtaCut_) <= maxNbInTop_;

            //place in final top list if it passes the threshold
            //if(discriminator > std::min(0.97, 0.80 + topCand.p().Pt()*0.15/300.0) /*discriminator_*/ && passBrequirements)
            if(discriminator > discriminator_ && passBrequirements)
            {
                tops.push_back(&topCand);
            }
        }
    }

    Py_DECREF(nparray);
    Py_DECREF(inputs);
    Py_DECREF(outputs);
    Py_DECREF(outputOpName);
    Py_DECREF(pArgs);

#endif
}

#ifdef DOTENSORFLOWPYBIND

TTMTFPyBind::~TTMTFPyBind()
{
    //finish cleanup of python objects and close interpreter
    Py_DECREF(pModule);
    Py_DECREF(pMain);
    Py_DECREF(pGlobal);
    Py_Finalize();
}


void TTMTFPyBind::initializePyInterpreter()
{
    // initialize the python interpreter 
    if(!Py_IsInitialized())
    {
        PyEval_InitThreads();
        Py_Initialize();
    }

    // create the main module
    pMain = PyImport_AddModule("__main__");

    // define the globals of the main module as our context
    pGlobal = PyModule_GetDict(pMain);

    // since PyModule_GetDict returns a borrowed reference, increase the count to own one
    Py_INCREF(pGlobal);

    // load the python interface module 
    pModule = PyRun_String(embeddedTensorflowScript.c_str(), Py_file_input, pGlobal, pGlobal);

    // initialize numpy api
    import_array();
}

PyObject* TTMTFPyBind::callPython(const std::string& func, PyObject* pArgs)
{
    if (pModule != NULL && pMain != NULL) 
    {
        PyObject* pFunc = PyObject_GetAttrString(pMain, func.c_str());
        // pFunc is a new reference

        if (pFunc && PyCallable_Check(pFunc)) 
        {
            PyObject* pValue = PyObject_CallObject(pFunc, pArgs);

            if (pValue != NULL) 
            {
                Py_DECREF(pValue);
            }
            else 
            {
                Py_DECREF(pFunc);
                Py_DECREF(pModule);
                Py_DECREF(pMain);
                PyErr_Print();
                THROW_TTEXCEPTION("Cannot call function \"" + func + "\"!!!");
            }
        }
        else 
        {
            if (PyErr_Occurred())
                PyErr_Print();
            THROW_TTEXCEPTION("Cannot find function \"" + func + "\"!!!");
        }
        Py_XDECREF(pFunc);
        Py_DECREF(pModule);
    }
    else 
    {
        PyErr_Print();
        THROW_TTEXCEPTION("Python interpreter not initialized!!!");
    }
    
    return NULL;
}

#endif
