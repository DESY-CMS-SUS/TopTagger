\section*{Top Tagging Algorithm}

Add description of algorithm and general options here

\section*{Installation Instructions}

\subsection*{Installing the tagger in C\-M\-S software release}

\subsubsection*{Standalone (edm free) install instructions within C\-M\-S\-S\-W}

These instructions explain how to install the top tagger in a standalone way (i.\-e. no cms\-Run or F\-W\-Lite required) but taking advantage of all the tools which come packaged with a C\-M\-S\-S\-W release. If you would rather not go through the hassle of installing R\-O\-O\-T/python/tensorflow, the C\-M\-S\-S\-W environment can be used to provide the necessary libraries and python modules


\begin{DoxyCode}
cmsrel CMSSW\_9\_4\_11
cd CMSSW\_9\_4\_11/src
cmsenv
git clone git@github.com:susy2015/\hyperlink{classTopTagger}{TopTagger}.git
cd \hyperlink{classTopTagger}{TopTagger}/\hyperlink{classTopTagger}{TopTagger}/test
./configure
make -j8 
\end{DoxyCode}


The test code can then be run identically to the completely standalone instructions found \href{../README.md#running-the-example}{\tt here}

\subsubsection*{Install tagger integrated in the edm framework}

These instructions explain how to install the top tagger code if you want to run the tagger during nano\-A\-O\-D production or other cms\-Run driven analysis tasks.

\paragraph*{Description of top tagger nano\-A\-O\-D format}

The tagger will save an abbreviated \hyperlink{classTopObject}{Top\-Object} for each top into the nano\-A\-O\-D. The information stored includes


\begin{DoxyCode}
nResolvedTop (\textcolor{keywordtype}{int}): The number of resolved tops in the event
ResolvedTop\_discriminator (float): The neural network discrimimnator for topness (1 is most top like, 0 is 
      least top like)
ResolvedTop\_pt (float): Pt of the top
ResolvedTop\_eta (float): Eta of the top
ResolvedTop\_phi (float): Phi of the top
ResolvedTop\_mass (float): Mass of the top
ResolvedTop\_j1Idx (int): Index of the first constituent jet in the main nanoAOD jet collection
ResolvedTop\_j2Idx (int): Index of the second constituent jet in the main nanoAOD jet collectino
ResolvedTop\_j3Idx (int): Index of the third constituent jet in the main nanoAOD jet collection
ResolvedTop\_type (int): The type of top (3 for resolved tops)
\end{DoxyCode}


In order to save space in the nano\-A\-O\-D only top objects passing a basic discriminator cut are saved.

\paragraph*{Instructions for saving tagger results to nano\-A\-O\-D with C\-M\-S\-S\-W\-\_\-9\-\_\-4\-\_\-11}

If starting from a fresh release of C\-M\-S\-S\-W run the following setup commands


\begin{DoxyCode}
\textcolor{preprocessor}{#get CMSSW release}
\textcolor{preprocessor}{}cmsrel CMSSW\_9\_4\_11
cd CMSSW\_9\_4\_11/src/
cmsenv
git cms-init
\end{DoxyCode}


The following additional packages should then be checked out to get the top tagging code and the qg\-Axis1 variable necessary for the latest versions of the tagger.


\begin{DoxyCode}
cd $\{CMSSW\_BASE\}/src
git cms-merge-topic -u pastika:AddAxis1\_946p1
git clone git@github.com:susy2015/\hyperlink{classTopTagger}{TopTagger}.git
scram b -j4
\end{DoxyCode}


The configuration file to generate nano\-A\-O\-D can then be generated with the following set of instructions via cms\-Driver.\-py and download the top tagger configuration file


\begin{DoxyCode}
cd $\{CMSSW\_BASE\}/src
cmsDriver.py test94X -s NANO --mc --eventcontent NANOAODSIM --datatier NANOAODSIM --filein [location of 
      miniAOD file] --no\_exec  --conditions \textcolor{keyword}{auto}:phase1\_2017\_realistic -n 100 --era Run2\_2017,
      run2\_nanoAOD\_94XMiniAODv1 --customise \hyperlink{classTopTagger}{TopTagger}/\hyperlink{classTopTagger}{TopTagger}/resolvedTagger\_cff.customizeResolvedTagger
mkdir -p $\{CMSSW\_BASE\}/src/\hyperlink{classTopTagger}{TopTagger}/\hyperlink{classTopTagger}{TopTagger}/data
getTaggerCfg.sh -o -n -t DeepResolved\_DeepCSV\_GR\_noDisc\_Release\_v1.0.0 -d $CMSSW\_BASE/src/
      \hyperlink{classTopTagger}{TopTagger}/\hyperlink{classTopTagger}{TopTagger}/data
\end{DoxyCode}


For running over 2016 M\-C insread use the following cms\-Driver command


\begin{DoxyCode}
cd $\{CMSSW\_BASE\}/src
cmsDriver.py test80X -s NANO --mc --eventcontent NANOAODSIM --datatier NANOAODSIM --filein [location of 
      miniAOD file] --no\_exec  --conditions \textcolor{keyword}{auto}:run2\_mc -n 100 --era Run2\_2016,run2\_miniAOD\_80XLegacy --customise 
      \hyperlink{classTopTagger}{TopTagger}/\hyperlink{classTopTagger}{TopTagger}/resolvedTagger\_cff.customizeResolvedTagger
\end{DoxyCode}


This will produce a file \char`\"{}test\mbox{[}80/94\mbox{]}\-X\-\_\-\-N\-A\-N\-O.\-py\char`\"{} which can be run as follows to produce a small test nano\-A\-O\-D file with the top tagger variables included


\begin{DoxyCode}
cmsRun test94X\_NANO.py
\end{DoxyCode}


\paragraph*{Instructions for running tagger with C\-M\-S\-S\-W 8\-\_\-0\-\_\-28\-\_\-patch1}

These instructions are not recomended. Please use the instruction above for C\-M\-S\-S\-W\-\_\-9\-\_\-4\-\_\-\-X in nano\-A\-O\-D.

In addition to the top tagger itself these instructions include the steps to configure additional packages, including the deep\-Flavor tagger (for the tagger itself along with the tensorflow configuration for 8\-X), a patch to the qg producer to produce the Axis1 variable, and a version of the jet toolbox with a minor bug fix,


\begin{DoxyCode}
\textcolor{preprocessor}{#get CMSSW release}
\textcolor{preprocessor}{}cmsrel CMSSW\_8\_0\_28\_patch1
cd CMSSW\_8\_0\_28\_patch1/src/
cmsenv
git cms-init
\textcolor{preprocessor}{#configure deep Flavor https://twiki.cern.ch/twiki/bin/viewauth/CMS/DeepJet}
\textcolor{preprocessor}{}git cms-merge-topic -u mverzett:Experimental\_DeepFlavour\_80X
cd RecoBTag/DeepFlavour/scripts/
wget -nv http:\textcolor{comment}{//www-ekp.physik.uni-karlsruhe.de/~harrendorf/tensorflow-cmssw8-0-26.tar.gz}
tar -zxf tensorflow-cmssw8-0-26.tar.gz
mv tensorflow-cmssw8-0-26-patch1/site-packages ../../Tensorflow/python
rm -rf tensorflow-cmssw8-0-26.tar.gz tensorflow-cmssw8-0-26-patch1/
cd \textcolor{stringliteral}{"$CMSSW\_BASE/src"}
scram setup \textcolor{stringliteral}{"RecoBTag/Tensorflow/py2-numpy-c-api.xml"}
cmsenv
\textcolor{preprocessor}{#patch to gq producer to add axis1}
\textcolor{preprocessor}{}git cms-merge-topic -u pastika:AddJetAxis1
\textcolor{preprocessor}{#patched version of jet toolbox}
\textcolor{preprocessor}{}git clone git@github.com:susy2015/JetToolbox.git JMEAnalysis/JetToolbox -b fix\_NoLep\_jetToolbox\_80X\_V3
\textcolor{preprocessor}{#download top tagger code }
\textcolor{preprocessor}{}git clone -b IntermediateRecipeV0 git@github.com:susy2015/\hyperlink{classTopTagger}{TopTagger}.git
\textcolor{preprocessor}{#compile everything }
\textcolor{preprocessor}{}scram b -j12
cd \hyperlink{classTopTagger}{TopTagger}/\hyperlink{classTopTagger}{TopTagger}/test
\textcolor{preprocessor}{#get qgl database file}
\textcolor{preprocessor}{}wget https:\textcolor{comment}{//raw.githubusercontent.com/cms-jet/QGLDatabase/master/SQLiteFiles/QGL\_cmssw8020\_v2.db}
\textcolor{preprocessor}{#get top tager cfg file and MVA model files }
\textcolor{preprocessor}{}../../Tools/getTaggerCfg.sh -t Intermediate\_Example\_v1.0.0
\textcolor{preprocessor}{#run example code}
\textcolor{preprocessor}{}voms-proxy-init
cmsRun run\_topTagger.py
\end{DoxyCode}


The default configuration of the example cfg file \char`\"{}run\-\_\-top\-Tagger.\-py\char`\"{} will run over a single-\/lepton ttbar sample and produce an edm formatted output file (\char`\"{}test.\-root\char`\"{}) containing the vector of reconstructed top T\-Lorentz\-Vectors along with a second vector indicating the type of top (monojet, dijet, trijet).

\subsubsection*{Instructions for producing jet variables for resolved top tagger in nano\-A\-O\-D}

The configuration file to generate nano\-A\-O\-D with top tagger variables can be generated with the following set of instructions via cms\-Driver.\-py


\begin{DoxyCode}
cd $\{CMSSW\_BASE\}/src
cmsDriver.py resolvedTaggerVariables -s NANO --mc --eventcontent NANOAODSIM --datatier NANOAODSIM --filein 
      [location of miniAOD file] --no\_exec  --conditions \textcolor{keyword}{auto}:phase1\_2017\_realistic -n 100 --era Run2\_2017,
      run2\_nanoAOD\_94XMiniAODv1 --customise \hyperlink{classTopTagger}{TopTagger}/\hyperlink{classTopTagger}{TopTagger}/resolvedTagger\_cff.
      customizeResolvedTaggerVariables
mkdir -p $\{CMSSW\_BASE\}/src/\hyperlink{classTopTagger}{TopTagger}/\hyperlink{classTopTagger}{TopTagger}/data
getTaggerCfg.sh -o -n -t DeepResolved\_DeepCSV\_GR\_noDisc\_Release\_v1.0.0 -d $CMSSW\_BASE/src/
      \hyperlink{classTopTagger}{TopTagger}/\hyperlink{classTopTagger}{TopTagger}/data
\end{DoxyCode}


\subsubsection*{O\-L\-D\-: Instructions for producing jet variables for resolved top tagger in C\-M\-S\-S\-W\-\_\-8\-\_\-0\-\_\-28\-\_\-patch1}

The solution using nano\-A\-O\-D is the recomended way to get resolved top tagger variables.

Setting up a new C\-M\-S\-S\-W 8\-\_\-0\-\_\-28\-\_\-patch1 release to produce the resolved top tagger variables.


\begin{DoxyCode}
\textcolor{preprocessor}{#get CMSSW release}
\textcolor{preprocessor}{}cmsrel CMSSW\_8\_0\_28\_patch1
cd CMSSW\_8\_0\_28\_patch1/src/
\textcolor{preprocessor}{#initialize cms and cms git commands }
\textcolor{preprocessor}{}cmsenv
git cms-init
\textcolor{preprocessor}{#patch to qg producer to add axis1}
\textcolor{preprocessor}{}git cms-merge-topic -u pastika:AddJetAxis1
\textcolor{preprocessor}{#compile}
\textcolor{preprocessor}{scram b -j8}
\end{DoxyCode}


The following code should be added to your C\-M\-S\-S\-W config file to prepare the jet collection with all necessary variables.


\begin{DoxyCode}
jetTag = cms.InputTag(\textcolor{stringliteral}{"slimmedJets"})

process.load(\textcolor{stringliteral}{'RecoJets.JetProducers.QGTagger\_cfi'})
process.QGTagger.srcJets   = cms.InputTag(\textcolor{stringliteral}{"slimmedJets"})

from PhysicsTools.PatAlgos.tools.jetTools \textcolor{keyword}{import} updateJetCollection

updateJetCollection(
   process,
   labelName = \textcolor{stringliteral}{"DeepCSV"},
   jetSource = cms.InputTag(\textcolor{stringliteral}{"slimmedJets"}),
   jetCorrections = (\textcolor{stringliteral}{'AK4PFchs'}, cms.vstring([\textcolor{stringliteral}{'L1FastJet'}, \textcolor{stringliteral}{'L2Relative'}, \textcolor{stringliteral}{'L3Absolute'}]), \textcolor{stringliteral}{'None'}),
   btagDiscriminators = [
      \textcolor{stringliteral}{'pfDeepCSVJetTags:probudsg'},
      \textcolor{stringliteral}{'pfDeepCSVJetTags:probb'},
      \textcolor{stringliteral}{'pfDeepCSVJetTags:probc'},
      \textcolor{stringliteral}{'pfDeepCSVJetTags:probbb'},
      \textcolor{stringliteral}{'pfDeepCSVJetTags:probcc'},
      ] ## to add discriminators                                                                           
                                                                                                                  
                             
)

process.updatedPatJetsDeepCSV.userData.userFloats.src += [\textcolor{stringliteral}{'QGTagger:qgLikelihood'}, \textcolor{stringliteral}{'QGTagger:ptD'}, \textcolor{stringliteral}{'
      QGTagger:axis1'}, \textcolor{stringliteral}{'QGTagger:axis2'},]
process.updatedPatJetsDeepCSV.userData.userInts.src += [\textcolor{stringliteral}{'QGTagger:mult'},]
\end{DoxyCode}


This will produce a jet collection called 'selected\-Updated\-Pat\-Jets\-Deep\-C\-S\-V' which contains all necessary variables for the resolved top tagger.

The necessary variables can then be accessed in a edm producer as follows


\begin{DoxyCode}
\{c++\}
\textcolor{comment}{//in constructor}
JetTok\_ = consumes<std::vector<pat::Jet> >(edm::InputTag(\textcolor{stringliteral}{"selectedUpdatedPatJetsDeepCSV"}));
\end{DoxyCode}



\begin{DoxyCode}
\{c++\}
\textcolor{comment}{//in produce(...)}
edm::Handle<std::vector<pat::Jet> > jets;
iEvent.getByToken(JetTok\_, jets);

\textcolor{keywordflow}{for}(\textcolor{keyword}{const} pat::Jet& jet : *jets)
\{
    \textcolor{comment}{//No need to keep jets below 20 GeV}
    \textcolor{keywordflow}{if}(jet.pt() < 20) \textcolor{keywordflow}{continue};

    TLorentzVector perJetLVec;
    perJetLVec.SetPtEtaPhiE( jet.pt(), jet.eta(), jet.phi(), jet.energy() );

    \textcolor{keywordtype}{double} qgPtD = jet.userFloat(\textcolor{stringliteral}{"QGTagger:ptD"});
    \textcolor{keywordtype}{double} qgAxis1 = jet.userFloat(\textcolor{stringliteral}{"QGTagger:axis1"});
    \textcolor{keywordtype}{double} qgAxis2 = jet.userFloat(\textcolor{stringliteral}{"QGTagger:axis2"});
    \textcolor{keywordtype}{double} qgMult = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(jet.userInt(\textcolor{stringliteral}{"QGTagger:mult"}));
    \textcolor{keywordtype}{double} deepCSVb = jet.bDiscriminator(\textcolor{stringliteral}{"pfDeepCSVJetTags:probb"});
    \textcolor{keywordtype}{double} deepCSVc = jet.bDiscriminator(\textcolor{stringliteral}{"pfDeepCSVJetTags:probc"});
    \textcolor{keywordtype}{double} deepCSVl = jet.bDiscriminator(\textcolor{stringliteral}{"pfDeepCSVJetTags:probudsg"});
    \textcolor{keywordtype}{double} deepCSVbb = jet.bDiscriminator(\textcolor{stringliteral}{"pfDeepCSVJetTags:probbb"});
    \textcolor{keywordtype}{double} deepCSVcc = jet.bDiscriminator(\textcolor{stringliteral}{"pfDeepCSVJetTags:probcc"});
    \textcolor{keywordtype}{double} btag = jet.bDiscriminator(\textcolor{stringliteral}{"pfCombinedInclusiveSecondaryVertexV2BJetTags"});
    \textcolor{keywordtype}{double} chargedHadronEnergyFraction = jet.chargedHadronEnergyFraction();
    \textcolor{keywordtype}{double} neutralHadronEnergyFraction = jet.neutralHadronEnergyFraction();
    \textcolor{keywordtype}{double} chargedEmEnergyFraction = jet.chargedEmEnergyFraction();
    \textcolor{keywordtype}{double} neutralEmEnergyFraction = jet.neutralEmEnergyFraction();
    \textcolor{keywordtype}{double} muonEnergyFraction = jet.muonEnergyFraction();
    \textcolor{keywordtype}{double} photonEnergyFraction = jet.photonEnergyFraction();
    \textcolor{keywordtype}{double} electronEnergyFraction = jet.electronEnergyFraction();
    \textcolor{keywordtype}{double} recoJetsHFHadronEnergyFraction = jet.HFHadronEnergyFraction();
    \textcolor{keywordtype}{double} recoJetsHFEMEnergyFraction = jet.HFEMEnergyFraction();
    \textcolor{keywordtype}{double} chargedHadronMultiplicity = jet.chargedHadronMultiplicity();
    \textcolor{keywordtype}{double} neutralHadronMultiplicity = jet.neutralHadronMultiplicity();
    \textcolor{keywordtype}{double} photonMultiplicity = jet.photonMultiplicity();
    \textcolor{keywordtype}{double} electronMultiplicity = jet.electronMultiplicity();
    \textcolor{keywordtype}{double} muonMultiplicity = jet.muonMultiplicity();
\}
\end{DoxyCode}


For convinenent use with the top tagger the 4-\/vector and each jet variable can be saved in a flat tuple in its own std\-::vector per event.

\subsection*{More about getting a configuration file}

Before the top tagger can be used the top tagger configuration file must be checked out. Configuration files for top tagger working points are stored in the Susy2015/\-Top\-Tagger\-Cfg repository and are published through releases. These should not be accessed directly, but instead you can use the script \char`\"{}get\-Tagger\-Cfg.\-sh\char`\"{} to download the working points desired. An example of a basic checkout of the standard working point for use with the example code (different working points are found here \href{https://github.com/susy2015/TopTaggerCfg/releases}{\tt https\-://github.\-com/susy2015/\-Top\-Tagger\-Cfg/releases}) is as follows


\begin{DoxyCode}
\textcolor{preprocessor}{#run the following once to set up the top tagger and add the "getTaggerCfg.sh" to the path}
\textcolor{preprocessor}{}source \hyperlink{classTopTagger}{TopTagger}/\hyperlink{classTopTagger}{TopTagger}/test/taggerSetup.sh
getTaggerCfg.sh -t MVAAK8\_Tight\_noQGL\_binaryCSV\_v1.0.2
\end{DoxyCode}


This will download the configuration file along with the M\-V\-A training file if appropriate into a directory. It will then softlink the files into your current directory so this script is intended to be run from the same directory as you will run your code. If you want the directory containing the configuration file and M\-V\-A file to be located elsewhere this can be specified with the \char`\"{}-\/d\char`\"{} option (Multiple run directories can point to the same directory, this can be helpful to save space as the random forest training files are quite large). If you have multiple configuration files you can specify a different name for the configuration file with the \char`\"{}-\/f\char`\"{} option. Finally, if you want to download the file without creating the softlinks use the \char`\"{}-\/n\char`\"{} option.

\subsection*{Top tagger structure}

The top tagger code is written to take modules which act on a central object to produce the final collection of top objects. The tagger framework consists of the following classes (found in Top\-Tagger/\-Top\-Tagger/)

\subsubsection*{Top Tagger Modules and the Configuration File.}

The configuration file is central to the functioning of the top tagger code. This file is a basic text file implemented to follow the structure of the H\-C\-A\-L configuration parser and the code can be found here \char`\"{}\-Top\-Tagger/\-Cfg\-Parser.\char`\"{} This code upon which this is based can be found here (\href{https://svnweb.cern.ch/cern/wsvn/cmshcos/trunk/hcalBase/include/hcal/cfg/?#aafaf15fcace155f9a3d702b52eb6d719}{\tt https\-://svnweb.\-cern.\-ch/cern/wsvn/cmshcos/trunk/hcal\-Base/include/hcal/cfg/?\#aafaf15fcace155f9a3d702b52eb6d719}). The configuration script is used to tell the top tagger what modules to run and in which order, in addition to allowing any parameters necessary for the tagger and each module to be defined cleanly in one place. An example configuration script can be found in Top\-Tagger/\-Top\-Tagger/test/\-Example\-\_\-\-Top\-Tagger.\-cfg

Modules are where all the real work of the top tagger is done. Each module performs a particular task and stores its results in a \hyperlink{classTopTaggerResults}{Top\-Tagger\-Results} object which will eventually be presented to the user as a summary of final results. All modules inherit from \hyperlink{classTTModule}{T\-T\-Module} and, as described in \hyperlink{classTTModule}{T\-T\-Module}\char`\"{} implement the 2 functions \char`\"{}get\-Parameter\char`\"{}s and \char`\"{}run." Each module is called automatically from the \hyperlink{classTopTagger}{Top\-Tagger} class. They are also instantiated automatically based upon the configuration file.

For further documentation of the code and each module see the following webpage \href{http://susy2015.github.io/TopTagger/html/index.html}{\tt http\-://susy2015.\-github.\-io/\-Top\-Tagger/html/index.\-html}.

\subsubsection*{\hyperlink{classTopTagger}{Top\-Tagger}}

The \hyperlink{classTopTagger}{Top\-Tagger} module is the primary (and only mandatory) section in every top tagger configuration. This section defines all the other top tagger modules which will be run and in which order. This module has 2 variables (both arrays) Which are used to define the module run order and if necessary the module context name.

\paragraph*{module\mbox{[}\mbox{]} (string)\-:}

This variable is an array and is used to define which other modules will be run and in which order. This can be any module listed here in this section.

\paragraph*{context\mbox{[}\mbox{]} (string)\-:}

This variable must be specified for any module being run more than once to specify what context name to read its configuration from. 