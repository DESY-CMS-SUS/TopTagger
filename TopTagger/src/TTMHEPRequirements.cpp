#include "TopTagger/TopTagger/include/TTMHEPRequirements.h"

#include <cmath>

#include "TopTagger/TopTagger/include/TopTaggerResults.h"

void TTMHEPRequirements::run(TopTaggerResults& ttResults)
{
    //Get the list of top candidates as generated by the clustering algo
    std::vector<TopObject>& topCandidates = ttResults.getTopCandidates();
    //Get the list of final tops into which we will stick candidates
    std::vector<TopObject*>& tops = ttResults.getTops();

    //For now I will be a terrible person and hardcode the cuts
    for(auto& topCand : topCandidates)
    {
        //Grab the list of constituents which make up this top candidate 
        const std::vector<Constituent const *>& jets = topCand.getConstituents();

        //HEP tagger requirements
        bool passHEPRequirments = true;

        //Constants which should be in some global include 
        const double mW = 80.385;
        const double mt = 173.5;
        const double Rmin = 0.85*mW/mt;
        const double Rmax = 1.25*mW/mt;

        //Get the total candidate mass
        double m123 = topCand.p().M();

        if(jets.size() == 3) //trijets
        {
            double m12  = (jets[0]->p() + jets[1]->p()).M();
            double m23  = (jets[1]->p() + jets[2]->p()).M();
            double m13  = (jets[0]->p() + jets[2]->p()).M();

            //Implement HEP mass ratio requirements here
            bool criterionA = 0.2 < atan(m13/m12) &&
                atan(m13/m12) < 1.3 &&
                Rmin < m23/m123 &&
                m23/m123 < Rmax;

            bool criterionB = (pow(Rmin, 2)*(1+pow(m13/m12, 2)) < (1 - pow(m23/m123, 2))) &&
                ((1 - pow(m23/m123, 2)) < pow(Rmax, 2)*(1 + pow(m13/m12, 2)));// &&
            //(m23/m123 > 0.35);

            bool criterionC = (pow(Rmin, 2)*(1+pow(m12/m13, 2)) < (1 - pow(m23/m123, 2))) &&
                ((1 - pow(m23/m123, 2)) < pow(Rmax, 2)*(1 + pow(m12/m13, 2)));// &&
            //(m23/m123 > 0.35);

            passHEPRequirments = criterionA || criterionB || criterionC;
        }
        else if(jets.size() == 2) //dijets
        {
            double m23  = jets[0]->p().M();
            double m123 = topCand.p().M();

            //Implement simplified HEP mass ratio requirements for di-jets here
            passHEPRequirments = Rmin < m23/m123 && m23/m123 < Rmax;
        }
        //Monojets get an automatic pass for now

        //Requirements on b-quarks
        //TERRIBLE HARDCODED CSV THRESHOLD HERE
        int Nb = 0;
        for(const auto& jet : jets) if(jet->getBTagDisc() > 0.890 && fabs(jet->p().Eta()) < 2.4) ++Nb;
        bool passBrequirements = (Nb <= 1);

        //If we pass the HEP and B requirements add top to final candidates list
        if(passHEPRequirments && passBrequirements)
        {
            tops.push_back(&topCand);
        }
    }
}
